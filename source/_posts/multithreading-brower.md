---
title: 浏览器的线程介绍
date: 2019-01-04 17:45:55
tags: 浏览器的线程介绍
---

### 浏览器的线程介绍
> 通常一个浏览器至少有3个常驻线程：js引擎线程(处理js),GUI渲染线程(浏览器页面渲染)，浏览器事件触发线程(事件触发控制)。
      1.js引擎线程。由于js引擎是基于事件驱动的单线程，所以js引擎会一直等待着任务队列中任务的到来并处理。浏览器无论什么时候都只有一个线程来运行js程序
      2.GUI渲染线程。当浏览器界面重绘或者回流时(重绘不一定触发回流，但是回流一定触发重绘，具体重绘和回流内容后面另专们研究，插个眼！！！)，由于js可以操作dom，从而改变真个dom tree，所以他和js引擎线程是互斥的。也就是，当js引擎线程处于运行状态时，GUI线程就处于冻结状态，当GUI线程处于运行状态时，js引擎线程就处于冻结状态
      3.浏览器事件触发线程，当一个事件被触发时，该线程会把这个事件添加到待处理队列的队尾，然后排队等待js引擎线程来处理

### 定时器setTimeout和setInterval
js引擎本身只能单线程运行，所以定时器需要由其他的外部线程来启动，所触发的事件也必须在队列中排队来等待js引擎的处理
```
setTimeOut(function(){while(1){}},1000)
setTimeOut(function(){console.log('1')},1500)
setTimeOut(function(){console.log('2')},100)
console.log('3')
```
打印出来的结果是  3 2

这是因为1s后第一个定时器里面的事件被优先放到队列里被js引擎执行，迟了500ms后的第二个定时器里的事件也被放到了队列的尾部，但是由于他队列前面的那个是个死循环，所以单线程的js引擎无法处理尾部的事件，造成浏览器假死的现象。



参考：
[浏览器UI线程和js线程](http://blog.csdn.net/u011643473/article/details/43192083)
[我了解到的JavaScript异步编程](https://juejin.im/post/599ff3d5f265da24843e6276)


